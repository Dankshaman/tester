using System;

// Token: 0x02000158 RID: 344
public static class LuaColor
{
	// Token: 0x04000B0D RID: 2829
	public const string script = "\r\nlocal Color = {}\r\nColor.__isColor = true\r\nColor.__version = '1.0.1'\r\n\r\nlocal colorMt = {}\r\n\r\nlocal function clamp(val)\r\n    return math.min(1, math.max(0, val or 0))\r\nend\r\nlocal function clampMultiple(a, b, c, d)\r\n    return clamp(a), clamp(b), clamp(c), clamp(d)\r\nend\r\n\r\nfunction Color.new(...)\r\n    local col = setmetatable({\r\n        r = 0,\r\n        g = 0,\r\n        b = 0,\r\n        a = 1\r\n    }, Color)\r\n\r\n    local argNum = select('#', ...)\r\n    if argNum == 1 and type(...) == 'table' then\r\n        -- Color.new(colorTable)\r\n        local arg = ...\r\n        col.r = clamp(arg.r or col.r)\r\n        col.g = clamp(arg.g or col.g)\r\n        col.b = clamp(arg.b or col.b)\r\n        col.a = clamp(arg.a or col.a)\r\n    elseif argNum == 3 then\r\n        -- Color.new(r, g, b)\r\n        col.r, col.g, col.b = clampMultiple(...)\r\n    elseif argNum == 4 then\r\n        col.r, col.g, col.b, col.a = clampMultiple(...)\r\n    end\r\n    \r\n    return col\r\nend\r\ncolorMt.__call = function(_, ...) return Color.new(...) end\r\n\r\nlocal function normalizeName(str)\r\n    return str:sub(1, 1):upper() .. str:sub(2, -1):lower()\r\nend\r\n\r\nlocal playerColors = {\r\n    ['white']  = Color.new(1, 1, 1),\r\n    ['brown']  = Color.new(0.443, 0.231, 0.09),\r\n    ['red']    = Color.new(0.856, 0.1, 0.094),\r\n    ['orange'] = Color.new(0.956, 0.392, 0.113),\r\n    ['yellow'] = Color.new(0.905, 0.898, 0.172),\r\n    ['green']  = Color.new(0.192, 0.701, 0.168),\r\n    ['teal']   = Color.new(0.129, 0.694, 0.607),\r\n    ['blue']   = Color.new(0.118, 0.53, 1),\r\n    ['purple'] = Color.new(0.627, 0.125, 0.941),\r\n    ['pink']   = Color.new(0.96, 0.439, 0.807),\r\n    ['grey']   = Color.new(0.5, 0.5, 0.5),\r\n    ['black']  = Color.new(0.25, 0.25, 0.25),\r\n}\r\ncolorMt.__index = function(_, colorName)\r\n    colorName = colorName:lower()\r\n    if playerColors[colorName] then\r\n        return playerColors[colorName]:copy()\r\n    end\r\n    return nil\r\nend\r\n\r\nColor.list = {}\r\nfor colorName in pairs(playerColors) do\r\n    table.insert(Color.list, normalizeName(colorName))\r\nend\r\n\r\nfunction Color.Add(name, color)\r\n    name = name:lower()\r\n    assert(not playerColors[name], 'Color ' .. name .. ' already defined')\r\n    assert(color.__isColor, tostring(color) .. ' is not a Color instance')\r\n    playerColors[name] = color\r\n    table.insert(Color.list, normalizeName(name))\r\nend\r\n\r\nfunction Color.fromString(strColor)\r\n    local color = assert(playerColors[strColor:lower()], strColor .. ' is not a valid color string')\r\n    return color:copy()\r\nend\r\n\r\nfunction Color.fromHex(hexColor)\r\n    local rStr, gStr, bStr, aStr = hexColor:match('^#?(%x%x)(%x%x)(%x%x)(%x?%x?)$')\r\n\r\n    assert(rStr and gStr and bStr and (aStr:len() == 0 or aStr:len() == 2), tostring(hexColor) .. ' is not a valid color hex string')\r\n\r\n    if aStr == '' then\r\n        return Color(\r\n            tonumber(rStr, 16)/255,\r\n            tonumber(gStr, 16)/255,\r\n            tonumber(bStr, 16)/255,\r\n            1\r\n        )\r\n    else\r\n        return Color(\r\n            tonumber(rStr, 16)/255,\r\n            tonumber(gStr, 16)/255,\r\n            tonumber(bStr, 16)/255,\r\n            tonumber(aStr, 16)/255\r\n        )\r\n    end\r\nend\r\n\r\n\r\nfunction Color:get()\r\n    return self.r, self.g, self.b, self.a\r\nend\r\n\r\nfunction Color:toHex(includeAlpha)\r\n    if includeAlpha then\r\n        return ('%02x%02x%02x%02x'):format(\r\n            self.r*255,\r\n            self.g*255,\r\n            self.b*255,\r\n            self.a*255\r\n        )\r\n    else\r\n        return ('%02x%02x%02x'):format(\r\n            self.r*255,\r\n            self.g*255,\r\n            self.b*255\r\n        )\r\n    end\r\nend\r\n\r\nfunction Color:toString(tolerance)\r\n    for name, color in pairs(playerColors) do\r\n        if self:equals(color, tolerance) then\r\n            return normalizeName(name)\r\n        end\r\n    end\r\n    return nil\r\nend\r\n\r\ndo\r\n    local remap = {'r', 'g', 'b', 'a'}\r\n    function Color:__index(k)\r\n        k = remap[k] or k\r\n        return rawget(self, k) or Color[k]\r\n    end\r\n    function Color:__newindex(k, v)\r\n        k = remap[k] or k\r\n        return rawset(self, k, v)\r\n    end\r\nend\r\n\r\nfunction Color:set(r, g, b, a)\r\n    self.r = clamp(r or self.r)\r\n    self.g = clamp(g or self.g)\r\n    self.b = clamp(b or self.b)\r\n    self.a = clamp(a or self.a)\r\nend\r\n\r\nfunction Color:setAt(key, value)\r\n    self[key] = clamp(value)\r\n    return self\r\nend\r\n\r\nfunction Color:equals(other, margin)\r\n    margin = margin or 1e-2\r\n    local diff = math.abs(self.r - other.r)\r\n        + math.abs(self.g - other.g)\r\n        + math.abs(self.b - other.b)\r\n        + math.abs(self.a - other.a)\r\n    return diff <= margin\r\nend\r\nColor.__eq = Color.equals\r\n\r\nfunction Color:copy()\r\n    return Color(self:get())\r\nend\r\n\r\nfunction Color:dump(prefix)\r\n    local name = self:toString()\r\n    local str = (self.a < 1) and '%s%s{ r = %f, g = %f, b = %f, a = %f }' or '%s%s{ r = %f, g = %f, b = %f }'\r\n    return (str:format(\r\n        prefix and (prefix .. ': ') or '',\r\n        name and (name .. ' ') or '',\r\n        self:get()\r\n        -- cut trailing zeroes from numbers\r\n    ):gsub('%.0+([ ,])', '%1'):gsub('%.(%d-)0+([ ,])', '.%1%2'))\r\nend\r\n\r\nfunction Color:__tostring()\r\n    return self:dump('Color')\r\nend\r\n\r\nfunction Color:lerp(other, t)\r\n    local mid = self:copy()\r\n    mid.r = mid.r + (other.r - self.r)*t\r\n    mid.g = mid.g + (other.g - self.g)*t\r\n    mid.b = mid.b + (other.b - self.b)*t\r\n    mid.a = mid.a + (other.a - self.a)*t\r\n    return mid\r\nend\r\n\r\nsetmetatable(Color, colorMt)\r\n\r\nreturn Color\r\n";
}
