using System;

// Token: 0x020001A2 RID: 418
public class LuaJSON
{
	// Token: 0x04000BEA RID: 3050
	public static string JSON = "-- -*- coding: utf-8 -*-\r\n-- http://regex.info/blog/lua/json\r\n-- \r\n-- Dan - Edited this quite a bit so we can .encode/.decode instead of :encode/:decode.\r\n-- The tradeoff is we can't use the strict types.\r\n--\r\n-- Simple JSON encoding and decoding in pure Lua.\r\n--\r\n-- Copyright 2010-2014 Jeffrey Friedl\r\n-- http://regex.info/blog/\r\n--\r\n-- Latest version: http://regex.info/blog/lua/json\r\n--\r\n-- This code is released under a Creative Commons CC-BY \"Attribution\" License:\r\n-- http://creativecommons.org/licenses/by/3.0/deed.en_US\r\n--\r\n-- It can be used for any purpose so long as the copyright notice above,\r\n-- the web-page links above, and the 'AUTHOR_NOTE' string below are\r\n-- maintained.Enjoy.\r\n--\r\nlocal VERSION = 20141223.14-- version history at end of file\r\nlocal AUTHOR_NOTE = \"-[ JSON.lua package by Jeffrey Friedl (http://regex.info/blog/lua/json) version 20141223.14 ]-\"\r\n\r\n--\r\n-- The 'AUTHOR_NOTE' variable exists so that information about the source\r\n-- of the package is maintained even in compiled versions.It's also\r\n-- included in OBJDEF below mostly to quiet warnings about unused variables.\r\n--\r\nlocal OBJDEF = {\r\n        VERSION = VERSION,\r\n   AUTHOR_NOTE = AUTHOR_NOTE,\r\n}\r\n\r\n\r\n--\r\n-- Simple JSON encoding and decoding in pure Lua.\r\n-- http://www.json.org/\r\n--\r\n--\r\n--   JSON = assert(loadfile \"JSON.lua\")()-- one-time load of the routines\r\n--\r\n--   local lua_value = JSON:decode(raw_json_text)\r\n--\r\n--   local raw_json_text = JSON:encode(lua_table_or_value)\r\n--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- \"pretty printed\" version for human readability\r\n--\r\n--\r\n--\r\n-- DECODING(from a JSON string to a Lua table)\r\n--\r\n--\r\n--   JSON = assert(loadfile \"JSON.lua\")() -- one-time load of the routines\r\n--\r\n--   local lua_value = JSON:decode(raw_json_text)\r\n--\r\n--   If the JSON text is for an object or an array, e.g.\r\n--     { \"what\": \"books\", \"count\": 3 }\r\n--   or\r\n--     [ \"Larry\", \"Curly\", \"Moe\" ]\r\n--\r\n--   the result is a Lua table, e.g.\r\n--     { what = \"books\", count = 3 }\r\n--   or\r\n--     { \"Larry\", \"Curly\", \"Moe\" }\r\n--\r\n--\r\n--   The encode and decode routines accept an optional second argument,\r\n--   \"etc\", which is not used during encoding or decoding, but upon error\r\n--   is passed along to error handlers.It can be of any type(including nil).\r\n--\r\n--\r\n--\r\n-- ERROR HANDLING\r\n--\r\n--   With most errors during decoding, this code calls\r\n--\r\n--      JSON:onDecodeError(message, text, location, etc)\r\n--\r\n--   with a message about the error, and if known, the JSON text being\r\n--   parsed and the byte count where the problem was discovered. You can\r\n--   replace the default JSON:onDecodeError() with your own function.\r\n--\r\n--   The default onDecodeError() merely augments the message with data\r\n--   about the text and the location if known (and if a second 'etc'\r\n--   argument had been provided to decode(), its value is tacked onto the\r\n--   message as well), and then calls JSON.assert(), which itself defaults\r\n--   to Lua's built-in assert(), and can also be overridden.\r\n--\r\n--   For example, in an Adobe Lightroom plugin, you might use something like\r\n--\r\n--          function JSON:onDecodeError(message, text, location, etc)\r\n--             LrErrors.throwUserError(\"Internal Error: invalid JSON data\")\r\n--          end\r\n--\r\n--   or even just\r\n--\r\n--          function JSON.assert(message)\r\n--             LrErrors.throwUserError(\"Internal Error: \" .. message)\r\n--          end\r\n--\r\n--   If JSON:decode() is passed a nil, this is called instead:\r\n--\r\n--      JSON:onDecodeOfNilError(message, nil, nil, etc)\r\n--\r\n--   and if JSON:decode() is passed HTML instead of JSON, this is called:\r\n--\r\n--      JSON:onDecodeOfHTMLError(message, text, nil, etc)\r\n--\r\n--   The use of the fourth 'etc' argument allows stronger coordination\r\n--   between decoding and error reporting, especially when you provide your\r\n--   own error-handling routines. Continuing with the the Adobe Lightroom\r\n--   plugin example:\r\n--\r\n--          function JSON:onDecodeError(message, text, location, etc)\r\n--             local note = \"Internal Error: invalid JSON data\"\r\n--             if type(etc) = 'table' and etc.photo then\r\n--                note = note .. \" while processing for \" .. etc.photo:getFormattedMetadata('fileName')\r\n--             end\r\n--             LrErrors.throwUserError(note)\r\n--          end\r\n--\r\n--            :\r\n--            :\r\n--\r\n--          for i, photo in ipairs(photosToProcess) do\r\n--               :             \r\n--               :             \r\n--               local data = JSON:decode(someJsonText, { photo = photo })\r\n--               :             \r\n--               :             \r\n--          end\r\n--\r\n--\r\n--\r\n--\r\n--\r\n-- DECODING AND STRICT TYPES\r\n--\r\n--   Because both JSON objects and JSON arrays are converted to Lua tables,\r\n--   it's not normally possible to tell which original JSON type a\r\n--   particular Lua table was derived from, or guarantee decode-encode\r\n--   round-trip equivalency.\r\n--\r\n--   However, if you enable strictTypes, e.g.\r\n--\r\n--      JSON = assert(loadfile \"JSON.lua\")() --load the routines\r\n--      JSON.strictTypes = true\r\n--\r\n--   then the Lua table resulting from the decoding of a JSON object or\r\n--   JSON array is marked via Lua metatable, so that when re-encoded with\r\n--   JSON:encode() it ends up as the appropriate JSON type.\r\n--\r\n--   (This is not the default because other routines may not work well with\r\n--   tables that have a metatable set, for example, Lightroom API calls.)\r\n    --\r\n    --\r\n    --ENCODING(from a lua table to a JSON string)\r\n    --\r\n    --   JSON = assert(loadfile \"JSON.lua\")()-- one - time load of the routines\r\n--\r\n--local raw_json_text = JSON:encode(lua_table_or_value)\r\n--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value)-- \"pretty printed\" version for human readability\r\n--local custom_pretty = JSON:encode(lua_table_or_value, etc, { pretty = true, indent = \"|  \", align_keys = false })\r\n--\r\n--On error during encoding, this code calls:\r\n--\r\n--JSON:onEncodeError(message, etc)\r\n--\r\n--   which you can override in your local JSON object.\r\n--\r\n--   The 'etc' in the error call is the second argument to encode()\r\n--   and encode_pretty(), or nil if it wasn't provided.\r\n--\r\n--\r\n-- PRETTY - PRINTING\r\n--\r\n--   An optional third argument, a table of options, allows a bit of\r\n--configuration about how the encoding takes place:\r\n--\r\n--pretty = JSON:encode(val, etc, {\r\n    --pretty = true,      -- if false, no other options matter\r\n--indent = \"   \",     --this provides for a three-space indent per nesting level\r\n--                                       align_keys = false, --see below\r\n--                                     })\r\n--\r\n--encode() and encode_pretty() are identical except that encode_pretty()\r\n--   provides a default options table if none given in the call:\r\n--\r\n--       { pretty = true, align_keys = false, indent = \"  \" }\r\n--\r\n--For example, if\r\n--\r\n--JSON:encode(data)\r\n--\r\n--   produces:\r\n--\r\n--      { \"city\":\"Kyoto\",\"climate\":{ \"avg_temp\":16,\"humidity\":\"high\",\"snowfall\":\"minimal\"},\"country\":\"Japan\",\"wards\":11}\r\n--\r\n--then\r\n--\r\n--      JSON: encode_pretty(data)\r\n --\r\n --   produces:\r\n--\r\n--      {\r\n    --\"city\": \"Kyoto\",\r\n--\"climate\": {\r\n        --\"avg_temp\": 16,\r\n--\"humidity\": \"high\",\r\n--\"snowfall\": \"minimal\"\r\n--        },\r\n--\"country\": \"Japan\",\r\n--\"wards\": 11\r\n--      }\r\n--\r\n--The following three lines return identical results:\r\n--JSON:encode_pretty(data)\r\n--       JSON: encode_pretty(data, nil, { pretty = true, align_keys = false, indent = \"  \" })\r\n--JSON:encode(data, nil, { pretty = true, align_keys = false, indent = \"  \" })\r\n--\r\n--An example of setting your own indent string:\r\n--\r\n--JSON:encode_pretty(data, nil, { pretty = true, indent = \"|    \" })\r\n--\r\n--produces:\r\n--\r\n--      {\r\n    --      | \"city\": \"Kyoto\",\r\n--      | \"climate\": {\r\n        --      |    | \"avg_temp\": 16,\r\n--      |    | \"humidity\": \"high\",\r\n--      |    | \"snowfall\": \"minimal\"\r\n-- |    },\r\n--      | \"country\": \"Japan\",\r\n--      | \"wards\": 11\r\n--      }\r\n--\r\n--An example of setting align_keys to true:\r\n--\r\n--JSON:encode_pretty(data, nil, { pretty = true, indent = \"  \", align_keys = true })\r\n--\r\n--produces:\r\n--\r\n--      {\r\n    --\"city\": \"Kyoto\",\r\n--\"climate\": {\r\n        --\"avg_temp\": 16,\r\n--\"humidity\": \"high\",\r\n--\"snowfall\": \"minimal\"\r\n--                   },\r\n--\"country\": \"Japan\",\r\n--\"wards\": 11\r\n--      }\r\n--\r\n--which I must admit is kinda ugly, sorry.This was the default for\r\n--encode_pretty() prior to version 20141223.14.\r\n--\r\n--\r\n--  AMBIGUOUS SITUATIONS DURING THE ENCODING\r\n--\r\n--   During the encode, if a Lua table being encoded contains both string\r\n--and numeric keys, it fits neither JSON's idea of an object, nor its\r\n--   idea of an array. To get around this, when any string key exists(or\r\n--   when non - positive numeric keys exist), numeric keys are converted to\r\n--   strings.\r\n--\r\n--   For example,\r\n--JSON:encode({ \"one\", \"two\", \"three\", SOMESTRING = \"some string\" }))\r\n--produces the JSON object\r\n--     { \"1\":\"one\",\"2\":\"two\",\"3\":\"three\",\"SOMESTRING\":\"some string\"}\r\n--\r\n--To prohibit this conversion and instead make it an error condition, set\r\n--JSON.noKeyConversion = true\r\n--\r\n\r\n\r\n\r\n\r\n--\r\n-- SUMMARY OF METHODS YOU CAN OVERRIDE IN YOUR LOCAL LUA JSON OBJECT\r\n--\r\n--assert\r\n--    onDecodeError\r\n--    onDecodeOfNilError\r\n--    onDecodeOfHTMLError\r\n--    onEncodeError\r\n--\r\n--  If you want to create a separate Lua JSON object with its own error handlers,\r\n--you can reload JSON.lua or use the :new() method.\r\n--\r\n-------------------------------------------------------------------------- -\r\n\r\nlocal default_pretty_indent = \"  \"\r\nlocal default_pretty_options = { pretty = true, align_keys = false, indent = default_pretty_indent }\r\n\r\nlocal isArray = { __tostring = function() return \"JSON array\"  end }\r\nisArray.__index  = isArray\r\nlocal isObject = { __tostring = function() return \"JSON object\" end }\r\nisObject.__index = isObject\r\n\r\n\r\nfunction OBJDEF:newArray(tbl)\r\n   return setmetatable(tbl or { }, isArray)\r\nend\r\n\r\nfunction OBJDEF:newObject(tbl)\r\n   return setmetatable(tbl or { }, isObject)\r\nend\r\n\r\nlocal function unicode_codepoint_as_utf8(codepoint)\r\n   --\r\n   -- codepoint is a number\r\n   --\r\n   if codepoint <= 127 then\r\n      return string.char(codepoint)\r\n\r\n   elseif codepoint <= 2047 then\r\n      --\r\n      -- 110yyyxx 10xxxxxx         <-- useful notation from http://en.wikipedia.org/wiki/Utf8\r\n      --\r\n      local highpart = math.floor(codepoint / 0x40)\r\n      local lowpart  = codepoint - (0x40 * highpart)\r\n      return string.char(0xC0 + highpart,\r\n                         0x80 + lowpart)\r\n\r\n   elseif codepoint <= 65535 then\r\n      --\r\n      -- 1110yyyy 10yyyyxx 10xxxxxx\r\n      --\r\n      local highpart  = math.floor(codepoint / 0x1000)\r\n      local remainder = codepoint - 0x1000 * highpart\r\n      local midpart   = math.floor(remainder / 0x40)\r\n      local lowpart   = remainder - 0x40 * midpart\r\n\r\n      highpart = 0xE0 + highpart\r\n      midpart  = 0x80 + midpart\r\n      lowpart  = 0x80 + lowpart\r\n\r\n      --\r\n      -- Check for an invalid character (thanks Andy R. at Adobe).\r\n      -- See table 3.7, page 93, in http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#G28070\r\n      --\r\n      if ( highpart == 0xE0 and midpart < 0xA0 ) or\r\n         ( highpart == 0xED and midpart > 0x9F ) or\r\n         ( highpart == 0xF0 and midpart < 0x90 ) or\r\n         ( highpart == 0xF4 and midpart > 0x8F )\r\n      then\r\n         return \"?\"\r\n      else\r\n         return string.char(highpart,\r\n                            midpart,\r\n                            lowpart)\r\n      end\r\n\r\n   else\r\n      --\r\n      -- 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx\r\n      --\r\n      local highpart  = math.floor(codepoint / 0x40000)\r\n      local remainder = codepoint - 0x40000 * highpart\r\n      local midA      = math.floor(remainder / 0x1000)\r\n      remainder       = remainder - 0x1000 * midA\r\n      local midB      = math.floor(remainder / 0x40)\r\n      local lowpart   = remainder - 0x40 * midB\r\n\r\n      return string.char(0xF0 + highpart,\r\n                         0x80 + midA,\r\n                         0x80 + midB,\r\n                         0x80 + lowpart)\r\n   end\r\nend\r\n\r\nfunction OBJDEF.onDecodeError(message, text, location, etc)\r\n   if text then\r\n      if location then\r\n         message = string.format(\"%s at char %d of: %s\", message, location, text)\r\n      else\r\n         message = string.format(\"%s: %s\", message, text)\r\n      end\r\n   end\r\n\r\n   if etc ~= nil then\r\n      message = message .. \" (\" .. OBJDEF.encode(etc) .. \")\"\r\n   end\r\n\r\n   if self.assert then\r\n      self.assert(false, message)\r\n   else\r\n      assert(false, message)\r\n   end\r\nend\r\n\r\nOBJDEF.onDecodeOfNilError  = OBJDEF.onDecodeError\r\nOBJDEF.onDecodeOfHTMLError = OBJDEF.onDecodeError\r\n\r\nfunction OBJDEF:onEncodeError(message, etc)\r\n   if etc ~= nil then\r\n      message = message .. \" (\" .. OBJDEF:encode(etc) .. \")\"\r\n   end\r\n\r\n   if self.assert then\r\n      self.assert(false, message)\r\n   else\r\n      assert(false, message)\r\n   end\r\nend\r\n\r\nlocal function grok_number(self, text, start, etc)\r\n   --\r\n   -- Grab the integer part\r\n   --\r\n   local integer_part = text:match('^-?[1-9]%d*', start)\r\n                     or text:match(\"^-?0\",        start)\r\n\r\n   if not integer_part then\r\n      --self:onDecodeError(\"expected number\", text, start, etc)\r\n      error('JSON.decode() expected number')\r\n   end\r\n\r\n   local i = start + integer_part:len()\r\n\r\n   --\r\n   -- Grab an optional decimal part\r\n   --\r\n   local decimal_part = text:match('^%.%d+', i) or \"\"\r\n\r\n   i = i + decimal_part:len()\r\n\r\n   --\r\n   -- Grab an optional exponential part\r\n   --\r\n   local exponent_part = text:match('^[eE][-+]?%d+', i) or \"\"\r\n\r\n   i = i + exponent_part:len()\r\n\r\n   local full_number_text = integer_part .. decimal_part .. exponent_part\r\n   local as_number = tonumber(full_number_text)\r\n\r\n   if not as_number then\r\n      --self:onDecodeError(\"bad number\", text, start, etc)\r\n      error('JSON.decode() found bad number')\r\n   end\r\n\r\n   return as_number, i\r\nend\r\n\r\n\r\nlocal function grok_string(self, text, start, etc)\r\n   if text:sub(start,start) ~= '\"' then\r\n      --self:onDecodeError(\"expected string's opening quote\", text, start, etc)\r\n      error('JSON.decode() expected string\\'s opening quote')\r\n   end\r\n\r\n   local i = start + 1 -- +1 to bypass the initial quote\r\n   local text_len = text:len()\r\n   local VALUE = \"\"\r\n   while i <= text_len do\r\n      local c = text:sub(i,i)\r\n      if c == '\"' then\r\n         return VALUE, i + 1\r\n      end\r\n      if c ~= '\\\\' then\r\n         VALUE = VALUE .. c\r\n         i = i + 1\r\n      elseif text:match('^\\\\b', i) then\r\n         VALUE = VALUE .. \"\\b\"\r\n         i = i + 2\r\n      elseif text:match('^\\\\f', i) then\r\n         VALUE = VALUE .. \"\\f\"\r\n         i = i + 2\r\n      elseif text:match('^\\\\n', i) then\r\n         VALUE = VALUE .. \"\\n\"\r\n         i = i + 2\r\n      elseif text:match('^\\\\r', i) then\r\n         VALUE = VALUE .. \"\\r\"\r\n         i = i + 2\r\n      elseif text:match('^\\\\t', i) then\r\n         VALUE = VALUE .. \"\\t\"\r\n         i = i + 2\r\n      else\r\n         local hex = text:match('^\\\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)\r\n         if hex then\r\n            i = i + 6 -- bypass what we just read\r\n\r\n            -- We have a Unicode codepoint. It could be standalone, or if in the proper range and\r\n            -- followed by another in a specific range, it'll be a two-code surrogate pair.\r\n            local codepoint = tonumber(hex, 16)\r\n            if codepoint >= 0xD800 and codepoint <= 0xDBFF then\r\n               -- it's a hi surrogate... see whether we have a following low\r\n               local lo_surrogate = text:match('^\\\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)\r\n               if lo_surrogate then\r\n                  i = i + 6 -- bypass the low surrogate we just read\r\n                  codepoint = 0x2400 + (codepoint - 0xD800) * 0x400 + tonumber(lo_surrogate, 16)\r\n               else\r\n                  -- not a proper low, so we'll just leave the first codepoint as is and spit it out.\r\n               end\r\n            end\r\n            VALUE = VALUE .. unicode_codepoint_as_utf8(codepoint)\r\n\r\n         else\r\n\r\n            -- just pass through what's escaped\r\n            VALUE = VALUE .. text:match('^\\\\(.)', i)\r\n            i = i + 2\r\n         end\r\n      end\r\n   end\r\n\r\n   --self:onDecodeError(\"unclosed string\", text, start, etc)\r\n   error('JSON.decode() found unclosed string')\r\nend\r\n\r\nlocal function skip_whitespace(text, start)\r\n\r\n   local _, match_end = text:find(\"^[ \\n\\r\\t]+\", start) -- [http://www.ietf.org/rfc/rfc4627.txt] Section 2\r\n   if match_end then\r\n      return match_end + 1\r\n   else\r\n      return start\r\n   end\r\nend\r\n\r\nlocal grok_one -- assigned later\r\n\r\nlocal function grok_object(self, text, start, etc)\r\n   if text:sub(start, start) ~= '{' then\r\n      --self:onDecodeError(\"expected '{'\", text, start, etc)\r\n      error('JSON.decode() expected \\'{\\'')\r\n   end\r\n\r\n   local i = skip_whitespace(text, start + 1) -- +1 to skip the '{'\r\n\r\n   --local VALUE = self.strictTypes and self:newObject { } or { }\r\n   local VALUE = {}\r\n\r\n   if text:sub(i, i) == '}' then\r\n      return VALUE, i + 1\r\n   end\r\n\r\n   local text_len = text:len()\r\n   while i <= text_len do\r\n      local key, new_i = grok_string(self, text, i, etc)\r\n\r\n      i = skip_whitespace(text, new_i)\r\n\r\n      if text:sub(i, i) ~= ':' then\r\n         --self:onDecodeError(\"expected colon\", text, i, etc)\r\n        error('JSON.decode() expected colon')\r\n      end\r\n\r\n      i = skip_whitespace(text, i + 1)\r\n\r\n      local new_val, new_i = grok_one(self, text, i)\r\n\r\n      VALUE[key] = new_val\r\n\r\n      --\r\n      -- Expect now either '}' to end things, or a ',' to allow us to continue.\r\n      --\r\n      i = skip_whitespace(text, new_i)\r\n\r\n      local c = text:sub(i, i)\r\n\r\n      if c == '}' then\r\n         return VALUE, i + 1\r\n      end\r\n\r\n      if text:sub(i, i) ~= ',' then\r\n         --self:onDecodeError(\"expected comma or '}'\", text, i, etc)\r\n         error('JSON.decode() expected comma or \\'}\\'')\r\n      end\r\n\r\n      i = skip_whitespace(text, i + 1)\r\n   end\r\n\r\n   --self:onDecodeError(\"unclosed '{'\", text, start, etc)\r\n    error('JSON.decode() found unclosed \\'{\\'')\r\nend\r\n\r\nlocal function grok_array(self, text, start, etc)\r\n   if text:sub(start, start) ~= '[' then\r\n       --self:onDecodeError(\"expected '['\", text, start, etc)\r\n       error('JSON.decode() expected \\'[\\'')\r\n   end\r\n\r\n   local i = skip_whitespace(text, start + 1) -- +1 to skip the '['\r\n   --local VALUE = self.strictTypes and self:newArray { } or { }\r\n   local VALUE = { }\r\n   if text:sub(i, i) == ']' then\r\n      return VALUE, i + 1\r\n   end\r\n\r\n   local VALUE_INDEX = 1\r\n\r\n   local text_len = text:len()\r\n   while i <= text_len do\r\n      local val, new_i = grok_one(self, text, i)\r\n\r\n      -- can't table.insert(VALUE, val) here because it's a no-op if val is nil\r\n      VALUE[VALUE_INDEX] = val\r\n      VALUE_INDEX = VALUE_INDEX + 1\r\n\r\n      i = skip_whitespace(text, new_i)\r\n\r\n      --\r\n      -- Expect now either ']' to end things, or a ',' to allow us to continue.\r\n      --\r\n      local c = text:sub(i, i)\r\n      if c == ']' then\r\n         return VALUE, i + 1\r\n      end\r\n      if text:sub(i, i) ~= ',' then\r\n         --self:onDecodeError(\"expected comma or '['\", text, i, etc)\r\n         error('JSON.decode() found unlcosed \\'[\\'')\r\n      end\r\n      i = skip_whitespace(text, i + 1)\r\n   end\r\n   --self:onDecodeError(\"unclosed '['\", text, start, etc)\r\n   error('JSON.decode() found unlcosed \\'[\\'')\r\nend\r\n\r\n\r\ngrok_one = function(self, text, start, etc)\r\n   -- Skip any whitespace\r\n   start = skip_whitespace(text, start)\r\n\r\n   if start > text:len() then\r\n      error('JSON.decode() found unexpected end of string')\r\n   end\r\n\r\n   if text:find('^\"', start) then\r\n      return grok_string(self, text, start, etc)\r\n\r\n   elseif text:find('^[-0123456789 ]', start) then\r\n      return grok_number(self, text, start, etc)\r\n\r\n   elsei[...string is too long...]";
}
