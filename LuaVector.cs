using System;

// Token: 0x020001A5 RID: 421
public class LuaVector
{
	// Token: 0x04000BF4 RID: 3060
	public const string script = "\r\nlocal Vector = {}\r\nVector.__isVector = true\r\nVector.__version = '1.0.1'\r\n\r\nfunction Vector.new(...)\r\n    local vec = setmetatable({\r\n        x = 0,\r\n        y = 0,\r\n        z = 0\r\n    }, Vector)\r\n    \r\n    local argNum = select('#', ...)\r\n    if argNum == 3 then\r\n        -- Vector.new(x, y, z)\r\n        vec.x, vec.y, vec.z = ...\r\n    elseif argNum == 1 and type(...) == 'table' then\r\n        -- Vector.new(table)\r\n        local src = ...\r\n        vec.x = src.x or src[1] or vec.x\r\n        vec.y = src.y or src[2] or vec.y\r\n        vec.z = src.z or src[3] or vec.z\r\n    end\r\n    \r\n    return vec\r\nend\r\nsetmetatable(Vector, {__call = function(_, ...) return Vector.new(...) end})\r\n\r\ndo\r\n    local remap = {'x', 'y', 'z'}\r\n    function Vector:__index(k)\r\n        k = remap[k] or k\r\n        return rawget(self, k) or Vector[k]\r\n    end\r\n    function Vector:__newindex(k, v)\r\n        k = remap[k] or k\r\n        return rawset(self, k, v)\r\n    end\r\nend\r\n\r\nfunction Vector:setAt(k, v)\r\n    self[k] = v\r\n    return self\r\nend\r\n\r\nfunction Vector:set(x, y, z)\r\n    self.x = x or self.x\r\n    self.y = y or self.y\r\n    self.z = z or self.z\r\n    return self\r\nend\r\n\r\nfunction Vector:get()\r\n    return self.x, self.y, self.z\r\nend\r\n\r\nfunction Vector:copy()\r\n    return Vector(self)\r\nend\r\n\r\nfunction Vector:add(other)\r\n    self.x = self.x + other.x\r\n    self.y = self.y + other.y\r\n    self.z = self.z + other.z\r\n    return self\r\nend\r\n\r\nfunction Vector.__add(v1, v2)\r\n    return v1:copy():add(v2)\r\nend\r\n\r\nfunction Vector:sub(other)\r\n    self.x = self.x - other.x\r\n    self.y = self.y - other.y\r\n    self.z = self.z - other.z\r\n    return self\r\nend\r\n\r\nfunction Vector.__sub(v1, v2)\r\n    return v1:copy():sub(v2)\r\nend\r\n\r\nfunction Vector:dot(other)\r\n    return self.x * other.x\r\n        + self.y * other.y\r\n        + self.z * other.z\r\nend\r\n\r\nfunction Vector:sqrMagnitude()\r\n    return self:dot(self)\r\nend\r\n\r\nfunction Vector:magnitude()\r\n    return math.sqrt(self:dot(self))\r\nend\r\n\r\nfunction Vector:scale(...)\r\n    local sx, sy, sz\r\n    \r\n    local argNum = select('#', ...)\r\n    if argNum == 1 then\r\n        local arg = ...\r\n        if type(arg) == 'number' then\r\n            -- vec:scale(number)\r\n            sx, sy, sz = arg, arg, arg\r\n        else\r\n            -- vec:scale(vector)\r\n            sx, sy, sz = arg:get()\r\n        end\r\n    elseif argNum == 3 then\r\n        -- vec:scale(x, y, z)\r\n        sx, sy, sz = ...\r\n        sx = sx or 1\r\n        sy = sy or 1\r\n        sz = sz or 1\r\n    end\r\n    \r\n    self.x = self.x * sx\r\n    self.y = self.y * sy\r\n    self.z = self.z * sz\r\n    return self\r\nend\r\n\r\nfunction Vector.__mul(val1, val2)\r\n    if type(val1) == 'number' then\r\n        val1, val2 = val2, val1\r\n    end\r\n    return val1:copy():scale(val2)\r\nend\r\n\r\nfunction Vector:sqrDistance(other)\r\n    local dx = self.x - other.x\r\n    local dy = self.y - other.y\r\n    local dz = self.z - other.z\r\n    return dx*dx + dy*dy + dz*dz\r\nend\r\n\r\nfunction Vector:distance(other)\r\n    return math.sqrt(self:sqrDistance(other))\r\nend\r\n\r\nfunction Vector:equals(other, margin)\r\n    margin = margin or 1e-3\r\n    return self:sqrDistance(other) <= margin\r\nend\r\n\r\nVector.__eq = Vector.equals\r\n\r\nfunction Vector:string(prefix)\r\n    prefix = prefix and (prefix .. ': ') or ''\r\n    return (('%s{ %f, %f, %f }'):format(\r\n        prefix,\r\n        self.x,\r\n        self.y,\r\n        self.z\r\n        -- cut trailing zeroes from numbers\r\n    ):gsub('%.0+([ ,])', '%1'):gsub('%.(%d-)0+([ ,])', '.%1%2'))\r\nend\r\n\r\nfunction Vector:__tostring()\r\n    return self:string('Vector')\r\nend\r\n\r\nfunction Vector:angle(other)\r\n    local cosAng = self:dot(other) / (self:magnitude() * other:magnitude())\r\n    return math.deg(math.acos(cosAng))\r\nend\r\n\r\nfunction Vector:clamp(maxLen)\r\n    local len = self:magnitude()\r\n    if len <= maxLen then\r\n        return self\r\n    end\r\n    local factor = maxLen/len\r\n    return self:scale(factor)\r\nend\r\n\r\nfunction Vector:cross(other)\r\n    return Vector(\r\n        self.y * other.z - self.z * other.y,\r\n        self.z * other.x - self.x * other.z,\r\n        self.x * other.y - self.y * other.x\r\n    )\r\nend\r\n\r\nfunction Vector.between(from, to)\r\n    return to - from\r\nend\r\n\r\nfunction Vector:lerp(target, t)\r\n    return self:between(target):scale(t):add(self)\r\nend\r\n\r\nfunction Vector:moveTowards(target, maxDist)\r\n    local delta = self:between(target):clamp(maxDist)\r\n    return self:add(delta)\r\nend\r\n\r\nfunction Vector:normalize()\r\n    local sqrLen = self:sqrMagnitude()\r\n    if sqrLen == 1 or sqrLen == 0 then\r\n        return self\r\n    end\r\n        \r\n    return self:scale(1/math.sqrt(sqrLen))\r\nend\r\n\r\nfunction Vector:normalized()\r\n    return self:copy():normalize()\r\nend\r\n\r\nfunction Vector:project(other)\r\n    if other:sqrMagnitude() ~= 1 then\r\n        other = other:normalized()\r\n    end\r\n    local scalar = self:dot(other)\r\n    return self:set(other:get()):scale(scalar)\r\nend\r\n\r\ndo\r\n    -- skew symmetric cross product\r\n    local function sscp(v)\r\n        return { Vector(   0,  -v.z,  v.y ),\r\n                 Vector(  v.z,   0,  -v.x ),\r\n                 Vector( -v.y,  v.x,   0  ) }\r\n    end\r\n    \r\n    --[[\r\n    local function mDump(m)\r\n        return ('{ %s,\\n  %s,\\n  %s }'):format(\r\n            m[1], m[2], m[3]\r\n        )\r\n    end\r\n    --]]\r\n    \r\n    local function qMult(x, y, z, w, factor)\r\n        return x*factor, y*factor, z*factor, w*factor\r\n    end\r\n    \r\n    local function qNormalize(x, y, z, w)\r\n        local norm = math.sqrt(x*x + y*y + z*z + w*w)\r\n        return qMult(x, y, z, w, 1/norm)\r\n    end\r\n    \r\n    -- interpolate quaternion\r\n    local function qSlerp(x, y, z, w, t)\r\n        local dot = w\r\n        if dot > 0.0005 then\r\n            return qNormalize(t*x, t*y, t*z, 1 + t*w - t)\r\n        end\r\n        \r\n        local th0 = math.acos(dot)\r\n        local th = th0*t\r\n        local sth = math.sin(th)\r\n        local sth0 = math.sin(th0)\r\n        \r\n        local s1 = sth/sth0\r\n        local s0 = math.cos(th) - dot*s1\r\n\r\n        return qMult(x, y, z, w + s0, s1)\r\n    end\r\n        \r\n    local function matrixToQuat(m, scale)\r\n        local w = math.sqrt(1.0 + m[1].x + m[2].y + m[3].z)/2;\r\n        local x = (m[3].y - m[2].z) / (w * 4)\r\n        local y = (m[1].z - m[3].x) / (w * 4)\r\n        local z = (m[2].x - m[1].y) / (w * 4)\r\n        if scale then\r\n            x, y, z, w = qSlerp(x, y, z, w, scale)\r\n        end\r\n        return x, y, z, w\r\n    end\r\n    \r\n    local function quatToMatrix(x, y, z, w)\r\n        return {\r\n            Vector(1-2*y*y-2*z*z, 2*x*y-2*z*w, 2*x*z+2*y*w),\r\n            Vector(2*x*y+2*z*w, 1-2*x*x-2*z*z, 2*y*z-2*x*w),\r\n            Vector(2*x*z-2*y*w, 2*y*z+2*x*w, 1-2*x*x-2*y*y)\r\n        }\r\n    end\r\n    \r\n    -- scale rotation matrix\r\n    local function mInterp(m, factor)\r\n        return quatToMatrix(matrixToQuat(m, factor))\r\n    end\r\n    \r\n    local function mScale(m, factor)\r\n        for _, row in ipairs(m) do\r\n            row:scale(factor)\r\n        end\r\n        return m\r\n    end\r\n    \r\n    -- apply a rotation matrix to vector\r\n    local function mApply(m, v)\r\n        v:set(m[1]:dot(v), m[2]:dot(v), m[3]:dot(v))\r\n        return v\r\n    end\r\n    \r\n    -- matrix multiplication\r\n    local function mMult(m1, m2)\r\n        local trans = {\r\n            Vector(m2[1].x, m2[2].x, m2[3].x),\r\n            Vector(m2[1].y, m2[2].y, m2[3].y),\r\n            Vector(m2[1].z, m2[2].z, m2[3].z),\r\n        }\r\n        local result = { Vector(), Vector(), Vector() }\r\n        for row = 1, 3 do\r\n            result[row]:set( m1[row]:dot(trans[1]), m1[row]:dot(trans[2]), m1[row]:dot(trans[3]) )\r\n        end\r\n        return result\r\n    end\r\n    \r\n    -- matrix addition\r\n    local function mAdd(m1, m2)\r\n        for row = 1, 3 do\r\n            m1[row]:add(m2[row])\r\n        end\r\n        return m1\r\n    end\r\n    \r\n    -- eye matrix\r\n    local function mUnit()\r\n        return { Vector(1, 0, 0),\r\n                 Vector(0, 1, 0),\r\n                 Vector(0, 0, 1) }\r\n    end\r\n    \r\n    local function rotationMatrix(from, to)\r\n        local sscross = sscp(from:cross(to))\r\n        local dot = from:dot(to)\r\n        -- maybe skew one of them instead to not bother the user\r\n        -- or include a bool/etc result\r\n        assert(math.abs(dot + 1) > 0.05, 'Vectors too close to opposite of each other')\r\n        local factor = 1 / (1 + dot)\r\n        local ss2scaled = mScale(mMult(sscross, sscross), factor)\r\n        return mAdd(mAdd(mUnit(), sscross), ss2scaled)\r\n    end\r\n    \r\n    local function mTrail(m)\r\n        return m[1].x + m[2].y + m[3].z\r\n    end\r\n    \r\n    -- Amount of rotation in degrees\r\n    local function mDeg(m)\r\n        return math.deg(math.acos((mTrail(m)-1)/2))\r\n    end    \r\n    \r\n    function Vector:rotateTowardsUnit(unitTarget, maxDelta)\r\n        local m = rotationMatrix(self, unitTarget)\r\n        if maxDelta then\r\n            local angle = mDeg(m)\r\n            if angle > maxDelta then\r\n                m = mInterp(m, maxDelta/angle)\r\n            end\r\n        end\r\n        return mApply(m, self)\r\n    end\r\n    \r\n    function Vector:rotateTowards(target, maxDelta)\r\n        local len = self:magnitude()\r\n        return self:normalize()\r\n            :rotateTowardsUnit(target:normalized(), maxDelta)\r\n            :scale(len)\r\n    end\r\n    \r\n    function Vector:reflect(planeNormal)\r\n        local x, y, z = planeNormal:normalized():get()\r\n        local reflectMatrix = {\r\n            Vector(1-2*x*x, -2*x*y, -2*x*z),\r\n            Vector(-2*x*y, 1-2*y*y, -2*y*z),\r\n            Vector(-2*x*z, -2*y*z, 1-2*z*z)\r\n        }\r\n        return mApply(reflectMatrix, self)\r\n    end\r\n    \r\n    local function basicRotationMatrix(axis, angle)\r\n        angle = math.rad(angle)\r\n        local sin, cos = math.sin(angle), math.cos(angle)\r\n        \r\n        if axis == 'x' then\r\n            return {\r\n                Vector( 1,   0,    0  ),\r\n                Vector( 0,  cos, -sin ),\r\n                Vector( 0,  sin,  cos )\r\n            }\r\n        elseif axis == 'y' then\r\n            return {\r\n                Vector( cos,  0,  sin ),\r\n                Vector(  0,   1,   0  ),\r\n                Vector(-sin,  0,  cos )\r\n            }\r\n        elseif axis == 'z' then\r\n            return {\r\n                Vector( cos, -sin,  0 ),\r\n                Vector( sin,  cos,  0 ),\r\n                Vector(  0,    0,   1 )\r\n            }\r\n        end\r\n    end    \r\n    \r\n    function Vector:rotateOver(axis, angle)\r\n        return mApply(basicRotationMatrix(axis, angle), self)\r\n    end\r\nend\r\n\r\nfunction Vector.max(v1, v2)\r\n    return Vector(\r\n        math.max(v1.x, v2.x),\r\n        math.max(v1.y, v2.y),\r\n        math.max(v1.z, v2.z)\r\n    )\r\nend\r\n\r\nfunction Vector.min(v1, v2)\r\n    return Vector(\r\n        math.min(v1.x, v2.x),\r\n        math.min(v1.y, v2.y),\r\n        math.min(v1.z, v2.z)\r\n    )\r\nend\r\n\r\nfunction Vector:inverse()\r\n    return self:set(-1*self.x, -1*self.y, -1*self.z)\r\nend\r\n\r\nfunction Vector:projectOnPlane(planeNormal)\r\n    local _, _, planeShadow = planeNormal:orthoNormalize(self)\r\n    if self:angle(planeShadow) > 90 then\r\n        planeShadow:inverse()\r\n    end\r\n    return self:project(planeShadow)\r\nend\r\n\r\nfunction Vector:orthoNormalize(binormalPlanar)\r\n    \r\n    -- if no vector was supplied, create an arbitrary one\r\n    if not binormalPlanar then\r\n        binormalPlanar = Vector(1, 0, 0)\r\n        if self:angle(binormalPlanar) < 10 then\r\n            binormalPlanar = Vector(0, 0, 1)\r\n        end\r\n    elseif binormalPlanar:sqrMagnitude() ~= 1 then\r\n        binormalPlanar = binormalPlanar:normalized()\r\n    end\r\n    \r\n    local base = self:normalized()\r\n    local normal = base:cross(binormalPlanar:normalized())\r\n    local binormal = base:cross(normal)\r\n   \r\n    return base, normal, binormal\r\nend\r\n\r\nfunction Vector:heading(axis)\r\n    if not axis then\r\n        return self:heading('x'), self:heading('y'), self:heading('z')\r\n    end\r\n    \r\n    local c1, c2\r\n    \r\n    if axis == 'x' then\r\n        c1, c2 = self.y, self.z\r\n    elseif axis == 'y' then\r\n        c1, c2 = self.x, self.z\r\n    elseif axis == 'z' then\r\n        c1, c2 = self.x, self.y\r\n    end\r\n    \r\n    return math.deg(math.atan2(c1, c2))\r\nend\r\n\r\nreturn Vector\r\n        ";
}
